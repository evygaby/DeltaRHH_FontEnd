/**
 * DevExtreme (cjs/__internal/scheduler/appointment_popup/m_form.js)
 * Version: 23.1.13
 * Build date: Mon Oct 28 2024
 *
 * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AppointmentForm = exports.APPOINTMENT_FORM_GROUP_NAMES = void 0;
require("../m_recurrence_editor");
require("../../../ui/text_area");
require("../../../ui/tag_box");
require("../../../ui/switch");
require("../../../ui/select_box");
var _devices = _interopRequireDefault(require("../../../core/devices"));
var _renderer = _interopRequireDefault(require("../../../core/renderer"));
var _date = _interopRequireDefault(require("../../../core/utils/date"));
var _date_serialization = _interopRequireDefault(require("../../../core/utils/date_serialization"));
var _extend = require("../../../core/utils/extend");
var _data_source = _interopRequireDefault(require("../../../data/data_source"));
var _message = _interopRequireDefault(require("../../../localization/message"));
var _semaphore = require("../../../renovation/ui/scheduler/utils/semaphore/semaphore");
var _form = _interopRequireDefault(require("../../../ui/form"));
var _m_expression_utils = require("../../scheduler/m_expression_utils");
var _m_appointment_adapter = require("../m_appointment_adapter");
var _m_utils_timezones_data = _interopRequireDefault(require("../timezones/m_utils_timezones_data"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    }
}

function _typeof(obj) {
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
    }, _typeof(obj)
}

function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key]
                }
            }
        }
        return target
    };
    return _extends.apply(this, arguments)
}

function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread()
}

function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) {
        return
    }
    if ("string" === typeof o) {
        return _arrayLikeToArray(o, minLen)
    }
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if ("Object" === n && o.constructor) {
        n = o.constructor.name
    }
    if ("Map" === n || "Set" === n) {
        return Array.from(o)
    }
    if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
        return _arrayLikeToArray(o, minLen)
    }
}

function _iterableToArray(iter) {
    if ("undefined" !== typeof Symbol && null != iter[Symbol.iterator] || null != iter["@@iterator"]) {
        return Array.from(iter)
    }
}

function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
        return _arrayLikeToArray(arr)
    }
}

function _arrayLikeToArray(arr, len) {
    if (null == len || len > arr.length) {
        len = arr.length
    }
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i]
    }
    return arr2
}

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) {
            descriptor.writable = true
        }
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor)
    }
}

function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) {
        _defineProperties(Constructor.prototype, protoProps)
    }
    if (staticProps) {
        _defineProperties(Constructor, staticProps)
    }
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor
}

function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return "symbol" === _typeof(key) ? key : String(key)
}

function _toPrimitive(input, hint) {
    if ("object" !== _typeof(input) || null === input) {
        return input
    }
    var prim = input[Symbol.toPrimitive];
    if (void 0 !== prim) {
        var res = prim.call(input, hint || "default");
        if ("object" !== _typeof(res)) {
            return res
        }
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return ("string" === hint ? String : Number)(input)
}
var SCREEN_SIZE_OF_SINGLE_COLUMN = 600;
var APPOINTMENT_FORM_GROUP_NAMES = {
    Main: "mainGroup",
    Recurrence: "recurrenceGroup"
};
exports.APPOINTMENT_FORM_GROUP_NAMES = APPOINTMENT_FORM_GROUP_NAMES;
var E2E_TEST_CLASSES = {
    form: "e2e-dx-scheduler-form",
    textEditor: "e2e-dx-scheduler-form-text",
    descriptionEditor: "e2e-dx-scheduler-form-description",
    startDateEditor: "e2e-dx-scheduler-form-start-date",
    endDateEditor: "e2e-dx-scheduler-form-end-date",
    startDateTimeZoneEditor: "e2e-dx-scheduler-form-start-date-timezone",
    endDateTimeZoneEditor: "e2e-dx-scheduler-form-end-date-timezone",
    allDaySwitch: "e2e-dx-scheduler-form-all-day-switch",
    recurrenceSwitch: "e2e-dx-scheduler-form-recurrence-switch"
};
var getStartDateWithStartHour = function(startDate, startDayHour) {
    return new Date(new Date(startDate).setHours(startDayHour))
};
var validateAppointmentFormDate = function(editor, value, previousValue) {
    var isCurrentDateCorrect = null === value || !!value;
    var isPreviousDateCorrect = null === previousValue || !!previousValue;
    if (!isCurrentDateCorrect && isPreviousDateCorrect) {
        editor.option("value", previousValue)
    }
};
var updateRecurrenceItemVisibility = function(recurrenceRuleExpr, value, form) {
    var _a;
    form.itemOption(APPOINTMENT_FORM_GROUP_NAMES.Recurrence, "visible", value);
    null === (_a = form.getEditor(recurrenceRuleExpr)) || void 0 === _a ? void 0 : _a.changeValueByVisibility(value)
};
var AppointmentForm = function() {
    function AppointmentForm(scheduler) {
        this.scheduler = scheduler;
        this.form = null;
        this.semaphore = new _semaphore.Semaphore
    }
    var _proto = AppointmentForm.prototype;
    _proto.create = function(triggerResize, changeSize, formData) {
        var _this = this;
        var _this$scheduler$getEd = this.scheduler.getEditingConfig(),
            allowTimeZoneEditing = _this$scheduler$getEd.allowTimeZoneEditing;
        var dataAccessors = this.scheduler.getDataAccessors();
        var expr = dataAccessors.expr;
        var isRecurrence = !!_m_expression_utils.ExpressionUtils.getField(dataAccessors, "recurrenceRule", formData);
        var colSpan = isRecurrence ? 1 : 2;
        var mainItems = [].concat(_toConsumableArray(this._createMainItems(expr, triggerResize, changeSize, allowTimeZoneEditing)), _toConsumableArray(this.scheduler.createResourceEditorModel()));
        changeSize(isRecurrence);
        var items = [{
            itemType: "group",
            name: APPOINTMENT_FORM_GROUP_NAMES.Main,
            colCountByScreen: {
                lg: 2,
                xs: 1
            },
            colSpan: colSpan,
            items: mainItems
        }, {
            itemType: "group",
            name: APPOINTMENT_FORM_GROUP_NAMES.Recurrence,
            visible: isRecurrence,
            colSpan: colSpan,
            items: this._createRecurrenceEditor(expr)
        }];
        var element = (0, _renderer.default)("<div>");
        this.scheduler.createComponent(element, _form.default, {
            items: items,
            showValidationSummary: true,
            scrollingEnabled: true,
            colCount: "auto",
            colCountByScreen: {
                lg: 2,
                xs: 1
            },
            formData: formData,
            showColonAfterLabel: false,
            labelLocation: "top",
            onInitialized: function(e) {
                _this.form = e.component
            },
            customizeItem: function(e) {
                if (_this.form && "group" === e.itemType) {
                    var dataExprs = _this.scheduler.getDataAccessors().expr;
                    var startDate = new Date(_this.formData[dataExprs.startDateExpr]);
                    var endDate = new Date(_this.formData[dataExprs.endDateExpr]);
                    var startTimeZoneEditor = e.items.find((function(i) {
                        return i.dataField === dataExprs.startDateTimeZoneExpr
                    }));
                    var endTimeZoneEditor = e.items.find((function(i) {
                        return i.dataField === dataExprs.endDateTimeZoneExpr
                    }));
                    if (startTimeZoneEditor) {
                        startTimeZoneEditor.editorOptions.dataSource = _this.createTimeZoneDataSource(startDate)
                    }
                    if (endTimeZoneEditor) {
                        endTimeZoneEditor.editorOptions.dataSource = _this.createTimeZoneDataSource(endDate)
                    }
                }
            },
            screenByWidth: function(width) {
                return width < SCREEN_SIZE_OF_SINGLE_COLUMN || "desktop" !== _devices.default.current().deviceType ? "xs" : "lg"
            },
            elementAttr: {
                class: E2E_TEST_CLASSES.form
            }
        })
    };
    _proto.createTimeZoneDataSource = function(date) {
        return new _data_source.default({
            store: _m_utils_timezones_data.default.getDisplayedTimeZones(date),
            paginate: true,
            pageSize: 10
        })
    };
    _proto._createAppointmentAdapter = function(rawAppointment) {
        return (0, _m_appointment_adapter.createAppointmentAdapter)(rawAppointment, this.scheduler.getDataAccessors())
    };
    _proto._dateBoxValueChanged = function(args, dateExpr, isNeedCorrect) {
        validateAppointmentFormDate(args.component, args.value, args.previousValue);
        var value = _date_serialization.default.deserializeDate(args.value);
        var previousValue = _date_serialization.default.deserializeDate(args.previousValue);
        var dateEditor = this.form.getEditor(dateExpr);
        var dateValue = _date_serialization.default.deserializeDate(dateEditor.option("value"));
        if (this.semaphore.isFree() && dateValue && value && isNeedCorrect(dateValue, value)) {
            var duration = previousValue ? dateValue.getTime() - previousValue.getTime() : 0;
            dateEditor.option("value", new Date(value.getTime() + duration))
        }
    };
    _proto._createTimezoneEditor = function(timeZoneExpr, secondTimeZoneExpr, visibleIndex, colSpan, isMainTimeZone, cssClass) {
        var _this2 = this;
        var visible = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : false;
        var noTzTitle = _message.default.format("dxScheduler-noTimezoneTitle");
        return {
            name: this.normalizeEditorName(timeZoneExpr),
            dataField: timeZoneExpr,
            editorType: "dxSelectBox",
            visibleIndex: visibleIndex,
            colSpan: colSpan,
            cssClass: cssClass,
            label: {
                text: " "
            },
            editorOptions: {
                displayExpr: "title",
                valueExpr: "id",
                placeholder: noTzTitle,
                searchEnabled: true,
                onValueChanged: function(args) {
                    var form = _this2.form;
                    var secondTimezoneEditor = form.getEditor(secondTimeZoneExpr);
                    if (isMainTimeZone) {
                        secondTimezoneEditor.option("value", args.value)
                    }
                }
            },
            visible: visible
        }
    };
    _proto._createDateBoxItems = function(dataExprs, allowTimeZoneEditing) {
        var _this3 = this;
        var colSpan = allowTimeZoneEditing ? 2 : 1;
        var firstDayOfWeek = this.scheduler.getFirstDayOfWeek();
        return [this.createDateBoxEditor(dataExprs.startDateExpr, colSpan, firstDayOfWeek, "dxScheduler-editorLabelStartDate", E2E_TEST_CLASSES.startDateEditor, (function(args) {
            _this3._dateBoxValueChanged(args, dataExprs.endDateExpr, (function(endValue, startValue) {
                return endValue < startValue
            }))
        })), this._createTimezoneEditor(dataExprs.startDateTimeZoneExpr, dataExprs.endDateTimeZoneExpr, 1, colSpan, true, E2E_TEST_CLASSES.startDateTimeZoneEditor, allowTimeZoneEditing), this.createDateBoxEditor(dataExprs.endDateExpr, colSpan, firstDayOfWeek, "dxScheduler-editorLabelEndDate", E2E_TEST_CLASSES.endDateEditor, (function(args) {
            _this3._dateBoxValueChanged(args, dataExprs.startDateExpr, (function(startValue, endValue) {
                return endValue < startValue
            }))
        })), this._createTimezoneEditor(dataExprs.endDateTimeZoneExpr, dataExprs.startDateTimeZoneExpr, 3, colSpan, false, E2E_TEST_CLASSES.endDateTimeZoneEditor, allowTimeZoneEditing)]
    };
    _proto._changeFormItemDateType = function(name, groupName, isAllDay) {
        var editorPath = this.getEditorPath(name, groupName);
        var itemEditorOptions = this.form.itemOption(editorPath).editorOptions;
        var type = isAllDay ? "date" : "datetime";
        var newEditorOption = _extends(_extends({}, itemEditorOptions), {
            type: type
        });
        this.form.itemOption(editorPath, "editorOptions", newEditorOption)
    };
    _proto._createMainItems = function(dataExprs, triggerResize, changeSize, allowTimeZoneEditing) {
        var _this4 = this;
        return [{
            name: this.normalizeEditorName(dataExprs.textExpr),
            dataField: dataExprs.textExpr,
            cssClass: E2E_TEST_CLASSES.textEditor,
            editorType: "dxTextBox",
            colSpan: 2,
            label: {
                text: _message.default.format("dxScheduler-editorLabelTitle")
            }
        }, {
            itemType: "group",
            colSpan: 2,
            colCountByScreen: {
                lg: 2,
                xs: 1
            },
            items: this._createDateBoxItems(dataExprs, allowTimeZoneEditing)
        }, {
            itemType: "group",
            colSpan: 2,
            colCountByScreen: {
                lg: 2,
                xs: 2
            },
            items: [{
                name: this.normalizeEditorName(dataExprs.allDayExpr),
                dataField: dataExprs.allDayExpr,
                cssClass: "dx-appointment-form-switch ".concat(E2E_TEST_CLASSES.allDaySwitch),
                editorType: "dxSwitch",
                label: {
                    text: _message.default.format("dxScheduler-allDay"),
                    location: "right"
                },
                editorOptions: {
                    onValueChanged: function(args) {
                        var value = args.value;
                        var startDateEditor = _this4.form.getEditor(dataExprs.startDateExpr);
                        var endDateEditor = _this4.form.getEditor(dataExprs.endDateExpr);
                        var startDate = _date_serialization.default.deserializeDate(startDateEditor.option("value"));
                        if (_this4.semaphore.isFree() && startDate) {
                            if (value) {
                                var allDayStartDate = _date.default.trimTime(startDate);
                                startDateEditor.option("value", new Date(allDayStartDate));
                                endDateEditor.option("value", new Date(allDayStartDate))
                            } else {
                                var startDateWithStartHour = getStartDateWithStartHour(startDate, _this4.scheduler.getStartDayHour());
                                var endDate = _this4.scheduler.getCalculatedEndDate(startDateWithStartHour);
                                startDateEditor.option("value", startDateWithStartHour);
                                endDateEditor.option("value", endDate)
                            }
                        }
                        _this4._changeFormItemDateType(dataExprs.startDateExpr, "Main", value);
                        _this4._changeFormItemDateType(dataExprs.endDateExpr, "Main", value)
                    }
                }
            }, {
                editorType: "dxSwitch",
                dataField: "repeat",
                cssClass: "dx-appointment-form-switch ".concat(E2E_TEST_CLASSES.recurrenceSwitch),
                name: "visibilityChanged",
                label: {
                    text: _message.default.format("dxScheduler-editorLabelRecurrence"),
                    location: "right"
                },
                editorOptions: {
                    onValueChanged: function(args) {
                        var form = _this4.form;
                        var colSpan = args.value ? 1 : 2;
                        form.itemOption(APPOINTMENT_FORM_GROUP_NAMES.Main, "colSpan", colSpan);
                        form.itemOption(APPOINTMENT_FORM_GROUP_NAMES.Recurrence, "colSpan", colSpan);
                        updateRecurrenceItemVisibility(dataExprs.recurrenceRuleExpr, args.value, form);
                        changeSize(args.value);
                        triggerResize()
                    }
                }
            }]
        }, {
            itemType: "empty",
            colSpan: 2
        }, {
            name: this.normalizeEditorName(dataExprs.descriptionExpr),
            dataField: dataExprs.descriptionExpr,
            cssClass: E2E_TEST_CLASSES.descriptionEditor,
            editorType: "dxTextArea",
            colSpan: 2,
            label: {
                text: _message.default.format("dxScheduler-editorLabelDescription")
            }
        }, {
            itemType: "empty",
            colSpan: 2
        }]
    };
    _proto._createRecurrenceEditor = function(dataExprs) {
        var _this5 = this;
        return [{
            name: this.normalizeEditorName(dataExprs.recurrenceRuleExpr),
            dataField: dataExprs.recurrenceRuleExpr,
            editorType: "dxRecurrenceEditor",
            editorOptions: {
                firstDayOfWeek: this.scheduler.getFirstDayOfWeek(),
                timeZoneCalculator: this.scheduler.getTimeZoneCalculator(),
                getStartDateTimeZone: function() {
                    return _this5._createAppointmentAdapter(_this5.formData).startDateTimeZone
                }
            },
            label: {
                text: " ",
                visible: false
            }
        }]
    };
    _proto.setEditorsType = function(allDay) {
        var _this$scheduler$getDa = this.scheduler.getDataAccessors().expr,
            startDateExpr = _this$scheduler$getDa.startDateExpr,
            endDateExpr = _this$scheduler$getDa.endDateExpr;
        var startDateItemPath = this.getEditorPath(startDateExpr, "Main");
        var endDateItemPath = this.getEditorPath(endDateExpr, "Main");
        var startDateFormItem = this.form.itemOption(startDateItemPath);
        var endDateFormItem = this.form.itemOption(endDateItemPath);
        if (startDateFormItem && endDateFormItem) {
            var startDateEditorOptions = startDateFormItem.editorOptions;
            var endDateEditorOptions = endDateFormItem.editorOptions;
            startDateEditorOptions.type = endDateEditorOptions.type = allDay ? "date" : "datetime";
            this.form.itemOption(startDateItemPath, "editorOptions", startDateEditorOptions);
            this.form.itemOption(endDateItemPath, "editorOptions", endDateEditorOptions)
        }
    };
    _proto.updateRecurrenceEditorStartDate = function(date, expression) {
        var options = {
            startDate: date
        };
        this.setEditorOptions(expression, "Recurrence", options)
    };
    _proto.setEditorOptions = function(name, groupName, options) {
        var editorPath = this.getEditorPath(name, groupName);
        var editor = this.form.itemOption(editorPath);
        editor && this.form.itemOption(editorPath, "editorOptions", (0, _extend.extend)({}, editor.editorOptions, options))
    };
    _proto.setTimeZoneEditorDataSource = function(date, name) {
        var dataSource = this.createTimeZoneDataSource(date);
        this.setEditorOptions(name, "Main", {
            dataSource: dataSource
        })
    };
    _proto.updateFormData = function(formData) {
        this.semaphore.take();
        this.form.option("formData", formData);
        var dataAccessors = this.scheduler.getDataAccessors();
        var expr = dataAccessors.expr;
        var rawStartDate = _m_expression_utils.ExpressionUtils.getField(dataAccessors, "startDate", formData);
        var rawEndDate = _m_expression_utils.ExpressionUtils.getField(dataAccessors, "endDate", formData);
        var allDay = _m_expression_utils.ExpressionUtils.getField(dataAccessors, "allDay", formData);
        var startDate = new Date(rawStartDate);
        var endDate = new Date(rawEndDate);
        this.setTimeZoneEditorDataSource(startDate, expr.startDateTimeZoneExpr);
        this.setTimeZoneEditorDataSource(endDate, expr.endDateTimeZoneExpr);
        this.updateRecurrenceEditorStartDate(startDate, expr.recurrenceRuleExpr);
        this.setEditorsType(allDay);
        this.semaphore.release()
    };
    _proto.createDateBoxEditor = function(dataField, colSpan, firstDayOfWeek, label, cssClass, onValueChanged) {
        return {
            editorType: "dxDateBox",
            name: this.normalizeEditorName(dataField),
            dataField: dataField,
            colSpan: colSpan,
            cssClass: cssClass,
            label: {
                text: _message.default.format(label)
            },
            validationRules: [{
                type: "required"
            }],
            editorOptions: {
                width: "100%",
                calendarOptions: {
                    firstDayOfWeek: firstDayOfWeek
                },
                onValueChanged: onValueChanged,
                useMaskBehavior: true
            }
        }
    };
    _proto.getEditorPath = function(name, groupName) {
        var normalizedName = this.normalizeEditorName(name);
        return "".concat(APPOINTMENT_FORM_GROUP_NAMES[groupName], ".").concat(normalizedName)
    };
    _proto.normalizeEditorName = function(name) {
        return name ? name.replace(/\./g, "_") : name
    };
    _createClass(AppointmentForm, [{
        key: "dxForm",
        get: function() {
            return this.form
        }
    }, {
        key: "readOnly",
        set: function(value) {
            this.form.option("readOnly", value);
            var recurrenceRuleExpr = this.scheduler.getDataAccessors().expr.recurrenceRuleExpr;
            var recurrenceEditor = this.form.getEditor(recurrenceRuleExpr);
            null === recurrenceEditor || void 0 === recurrenceEditor ? void 0 : recurrenceEditor.option("readOnly", value)
        }
    }, {
        key: "formData",
        get: function() {
            return this.form.option("formData")
        },
        set: function(value) {
            this.form.option("formData", value)
        }
    }]);
    return AppointmentForm
}();
exports.AppointmentForm = AppointmentForm;
