/**
 * DevExtreme (cjs/__internal/grids/grid_core/focus/m_focus.js)
 * Version: 23.1.13
 * Build date: Mon Oct 28 2024
 *
 * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.focusModule = exports.FocusController = void 0;
var _renderer = _interopRequireDefault(require("../../../../core/renderer"));
var _common = require("../../../../core/utils/common");
var _deferred = require("../../../../core/utils/deferred");
var _iterator = require("../../../../core/utils/iterator");
var _type = require("../../../../core/utils/type");
var _m_editing_utils = require("../editing/m_editing_utils");
var _m_modules = _interopRequireDefault(require("../m_modules"));
var _m_utils = _interopRequireDefault(require("../m_utils"));
var _m_focus_utils = require("./m_focus_utils");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    }
}

function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass)
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, p) {
        o.__proto__ = p;
        return o
    };
    return _setPrototypeOf(o, p)
}
var ROW_FOCUSED_CLASS = "dx-row-focused";
var FOCUSED_ROW_SELECTOR = ".dx-row.".concat(ROW_FOCUSED_CLASS);
var TABLE_POSTFIX_CLASS = "table";
var CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled";
var FocusController = function(_core$ViewController) {
    _inheritsLoose(FocusController, _core$ViewController);

    function FocusController() {
        return _core$ViewController.apply(this, arguments) || this
    }
    var _proto = FocusController.prototype;
    _proto.getKeyboardController = function() {
        return this.getController("keyboardNavigation")
    };
    _proto.getDataController = function() {
        return this.getController("data")
    };
    _proto.init = function() {
        this.component._optionsByReference.focusedRowKey = true
    };
    _proto.optionChanged = function(args) {
        var name = args.name,
            value = args.value,
            previousValue = args.previousValue;
        switch (name) {
            case "focusedRowIndex":
                this._focusRowByIndex(value);
                this.getKeyboardController()._fireFocusedRowChanged();
                args.handled = true;
                break;
            case "focusedRowKey":
                if (Array.isArray(value) && JSON.stringify(value) === JSON.stringify(previousValue)) {
                    return
                }
                this._focusRowByKey(value);
                this.getKeyboardController()._fireFocusedRowChanged();
                args.handled = true;
                break;
            case "focusedColumnIndex":
            case "focusedRowEnabled":
            case "autoNavigateToFocusedRow":
                args.handled = true;
                break;
            default:
                _core$ViewController.prototype.optionChanged.call(this, args)
        }
    };
    _proto.publicMethods = function() {
        return ["navigateToRow", "isRowFocused"]
    };
    _proto.isAutoNavigateToFocusedRow = function() {
        return "infinite" !== this.option("scrolling.mode") && this.option("autoNavigateToFocusedRow")
    };
    _proto._focusRowByIndex = function(index, operationTypes) {
        if (!this.option("focusedRowEnabled")) {
            return
        }
        index = void 0 !== index ? index : this.option("focusedRowIndex");
        if (index < 0) {
            if (this.isAutoNavigateToFocusedRow()) {
                this._resetFocusedRow()
            }
        } else {
            this._focusRowByIndexCore(index, operationTypes)
        }
    };
    _proto._focusRowByIndexCore = function(index, operationTypes) {
        var _this = this;
        var pageSize = this.getDataController().pageSize();
        var setKeyByIndex = function() {
            if (_this._isValidFocusedRowIndex(index)) {
                var rowIndex = index - _this.getDataController().getRowIndexOffset(true);
                if (!operationTypes || operationTypes.paging && !operationTypes.filtering) {
                    var lastItemIndex = _this.getDataController()._getLastItemIndex();
                    rowIndex = Math.min(rowIndex, lastItemIndex)
                }
                var focusedRowKey = _this.getDataController().getKeyByRowIndex(rowIndex, true);
                if ((0, _type.isDefined)(focusedRowKey) && !_this.isRowFocused(focusedRowKey)) {
                    _this.option("focusedRowKey", focusedRowKey)
                }
            }
        };
        if (pageSize >= 0) {
            if (!this._isLocalRowIndex(index)) {
                var pageIndex = Math.floor(index / this.getDataController().pageSize());
                (0, _deferred.when)(this.getDataController().pageIndex(pageIndex), this.getDataController().waitReady()).done((function() {
                    setKeyByIndex()
                }))
            } else {
                setKeyByIndex()
            }
        }
    };
    _proto._isLocalRowIndex = function(index) {
        var isVirtualScrolling = this.getKeyboardController()._isVirtualScrolling();
        if (isVirtualScrolling) {
            var pageIndex = Math.floor(index / this.getDataController().pageSize());
            var virtualItems = this.getDataController().virtualItemsCount();
            var virtualItemsBegin = virtualItems ? virtualItems.begin : -1;
            var visibleRowsCount = this.getDataController().getVisibleRows().length + this.getDataController().getRowIndexOffset();
            var visiblePagesCount = Math.ceil(visibleRowsCount / this.getDataController().pageSize());
            return virtualItemsBegin <= index && visiblePagesCount > pageIndex
        }
        return true
    };
    _proto._setFocusedRowKeyByIndex = function(index) {
        if (this._isValidFocusedRowIndex(index)) {
            var rowIndex = Math.min(index - this.getDataController().getRowIndexOffset(), this.getDataController().items().length - 1);
            var focusedRowKey = this.getDataController().getKeyByRowIndex(rowIndex);
            if ((0, _type.isDefined)(focusedRowKey) && !this.isRowFocused(focusedRowKey)) {
                this.option("focusedRowKey", focusedRowKey)
            }
        }
    };
    _proto._focusRowByKey = function(key) {
        if (!(0, _type.isDefined)(key)) {
            this._resetFocusedRow()
        } else {
            this._navigateToRow(key, true)
        }
    };
    _proto._resetFocusedRow = function() {
        var focusedRowKey = this.option("focusedRowKey");
        var isFocusedRowKeyDefined = (0, _type.isDefined)(focusedRowKey);
        if (!isFocusedRowKeyDefined && this.option("focusedRowIndex") < 0) {
            return
        }
        if (isFocusedRowKeyDefined) {
            this.option("focusedRowKey", null)
        }
        this.getKeyboardController().setFocusedRowIndex(-1);
        this.option("focusedRowIndex", -1);
        this.getDataController().updateItems({
            changeType: "updateFocusedRow",
            focusedRowKey: null
        });
        this.getKeyboardController()._fireFocusedRowChanged()
    };
    _proto._isValidFocusedRowIndex = function(rowIndex) {
        var row = this.getDataController().getVisibleRows()[rowIndex];
        return !row || "data" === row.rowType || "group" === row.rowType
    };
    _proto.navigateToRow = function(key) {
        if (!this.isAutoNavigateToFocusedRow()) {
            this.option("focusedRowIndex", -1)
        }
        return this._navigateToRow(key)
    };
    _proto._navigateToRow = function(key, needFocusRow) {
        var _this2 = this;
        var that = this;
        var isAutoNavigate = that.isAutoNavigateToFocusedRow();
        var d = new _deferred.Deferred;
        if (void 0 === key || !this.getDataController().dataSource()) {
            return d.reject().promise()
        }
        var rowIndexByKey = that.getFocusedRowIndexByKey(key);
        if (!isAutoNavigate && needFocusRow || rowIndexByKey >= 0) {
            that._navigateTo(key, d, needFocusRow)
        } else {
            this.getDataController().getPageIndexByKey(key).done((function(pageIndex) {
                if (pageIndex < 0) {
                    d.resolve(-1);
                    return
                }
                if (pageIndex === _this2.getDataController().pageIndex()) {
                    _this2.getDataController().reload().done((function() {
                        if (that.isRowFocused(key) && _this2.getDataController().getRowIndexByKey(key) >= 0) {
                            d.resolve(that.getFocusedRowIndexByKey(key))
                        } else {
                            that._navigateTo(key, d, needFocusRow)
                        }
                    })).fail(d.reject)
                } else {
                    _this2.getDataController().pageIndex(pageIndex).done((function() {
                        that._navigateTo(key, d, needFocusRow)
                    })).fail(d.reject)
                }
            })).fail(d.reject)
        }
        return d.promise()
    };
    _proto._navigateTo = function(key, deferred, needFocusRow) {
        var visibleRowIndex = this.getDataController().getRowIndexByKey(key);
        var isVirtualRowRenderingMode = _m_utils.default.isVirtualRowRendering(this);
        var isAutoNavigate = this.isAutoNavigateToFocusedRow();
        if (isAutoNavigate && isVirtualRowRenderingMode && visibleRowIndex < 0) {
            this._navigateToVirtualRow(key, deferred, needFocusRow)
        } else {
            this._navigateToVisibleRow(key, deferred, needFocusRow)
        }
    };
    _proto._navigateToVisibleRow = function(key, deferred, needFocusRow) {
        if (needFocusRow) {
            this._triggerUpdateFocusedRow(key, deferred)
        } else {
            var focusedRowIndex = this.getFocusedRowIndexByKey(key);
            this.getView("rowsView").scrollToRowElement(key, deferred).done((function() {
                deferred.resolve(focusedRowIndex)
            }))
        }
    };
    _proto._navigateToVirtualRow = function(key, deferred, needFocusRow) {
        var _this3 = this;
        var rowsScrollController = this.getDataController()._rowsScrollController;
        var rowIndex = _m_utils.default.getIndexByKey(key, this.getDataController().items(true));
        var scrollable = this.getView("rowsView").getScrollable();
        if (rowsScrollController && scrollable && rowIndex >= 0) {
            var focusedRowIndex = rowIndex + this.getDataController().getRowIndexOffset(true);
            var offset = rowsScrollController.getItemOffset(focusedRowIndex);
            this.component.on("contentReady", (function triggerUpdateFocusedRow() {
                if (_this3.getDataController().totalCount() && !_this3.getDataController().items().length) {
                    return
                }
                _this3.component.off("contentReady", triggerUpdateFocusedRow);
                if (needFocusRow) {
                    _this3._triggerUpdateFocusedRow(key, deferred)
                } else {
                    deferred.resolve(focusedRowIndex)
                }
            }));
            this.getView("rowsView").scrollTopPosition(offset)
        } else {
            deferred.resolve(-1)
        }
    };
    _proto._triggerUpdateFocusedRow = function(key, deferred) {
        var _this4 = this;
        var focusedRowIndex = this.getFocusedRowIndexByKey(key);
        if (this._isValidFocusedRowIndex(focusedRowIndex)) {
            var d;
            if (this.option("focusedRowEnabled")) {
                this.getDataController().updateItems({
                    changeType: "updateFocusedRow",
                    focusedRowKey: key
                })
            } else {
                d = this.getView("rowsView").scrollToRowElement(key)
            }(0, _deferred.when)(d).done((function() {
                _this4.getKeyboardController().setFocusedRowIndex(focusedRowIndex);
                deferred && deferred.resolve(focusedRowIndex)
            }))
        } else {
            deferred && deferred.resolve(-1)
        }
    };
    _proto.getFocusedRowIndexByKey = function(key) {
        var loadedRowIndex = this.getDataController().getRowIndexByKey(key, true);
        return loadedRowIndex >= 0 ? loadedRowIndex + this.getDataController().getRowIndexOffset(true) : -1
    };
    _proto._focusRowByKeyOrIndex = function() {
        var _this5 = this;
        var focusedRowKey = this.option("focusedRowKey");
        var currentFocusedRowIndex = this.option("focusedRowIndex");
        if ((0, _type.isDefined)(focusedRowKey)) {
            var visibleRowIndex = this.getDataController().getRowIndexByKey(focusedRowKey);
            if (visibleRowIndex >= 0) {
                if (this.getKeyboardController()._isVirtualScrolling()) {
                    currentFocusedRowIndex = visibleRowIndex + this.getDataController().getRowIndexOffset()
                }
                this.getKeyboardController().setFocusedRowIndex(currentFocusedRowIndex);
                this._triggerUpdateFocusedRow(focusedRowKey)
            } else {
                this._navigateToRow(focusedRowKey, true).done((function(focusedRowIndex) {
                    if (currentFocusedRowIndex >= 0 && focusedRowIndex < 0) {
                        _this5._focusRowByIndex()
                    } else if (currentFocusedRowIndex < 0 && focusedRowIndex >= 0) {
                        _this5.getKeyboardController().setFocusedRowIndex(focusedRowIndex)
                    }
                }))
            }
        } else if (currentFocusedRowIndex >= 0) {
            this._focusRowByIndex(currentFocusedRowIndex)
        }
    };
    _proto.isRowFocused = function(key) {
        var focusedRowKey = this.option("focusedRowKey");
        if ((0, _type.isDefined)(focusedRowKey)) {
            return (0, _common.equalByValue)(key, this.option("focusedRowKey"))
        }
        return
    };
    _proto.updateFocusedRow = function(e) {
        var _a;
        var that = this;
        var focusedRowIndex = null !== (_a = e.focusedRowIndex) && void 0 !== _a ? _a : that.getDataController().getRowIndexByKey(e.focusedRowKey);
        var rowsView = that.getView("rowsView");
        var $tableElement;
        var $mainRow;
        (0, _iterator.each)(rowsView.getTableElements(), (function(index, element) {
            var isMainTable = 0 === index;
            $tableElement = (0, _renderer.default)(element);
            that._clearPreviousFocusedRow($tableElement, focusedRowIndex);
            var $row = that._prepareFocusedRow({
                changedItem: that.getDataController().getVisibleRows()[focusedRowIndex],
                $tableElement: $tableElement,
                focusedRowIndex: focusedRowIndex
            });
            if (isMainTable) {
                $mainRow = $row
            }
        }));
        if (!e.preventScroll && $mainRow) {
            rowsView.scrollToElementVertically($mainRow)
        }
    };
    _proto._clearPreviousFocusedRow = function($tableElement, focusedRowIndex) {
        var _this6 = this;
        var $prevRowFocusedElement = $tableElement.find(FOCUSED_ROW_SELECTOR).filter((function(_, focusedRow) {
            var $focusedRowTable = (0, _renderer.default)(focusedRow).closest(".".concat(_this6.addWidgetPrefix(TABLE_POSTFIX_CLASS)));
            return $tableElement.is($focusedRowTable)
        }));
        $prevRowFocusedElement.removeClass(ROW_FOCUSED_CLASS).removeClass(CELL_FOCUS_DISABLED_CLASS).removeAttr("tabindex");
        $prevRowFocusedElement.children("td").removeAttr("tabindex");
        if (0 !== focusedRowIndex) {
            var $firstRow = (0, _renderer.default)(this.getView("rowsView").getRowElement(0));
            $firstRow.removeClass(CELL_FOCUS_DISABLED_CLASS).removeAttr("tabIndex")
        }
    };
    _proto._prepareFocusedRow = function(options) {
        var $row;
        var changedItem = options.changedItem;
        if (changedItem && ("data" === changedItem.rowType || "group" === changedItem.rowType)) {
            var focusedRowIndex = options.focusedRowIndex;
            var $tableElement = options.$tableElement;
            var tabIndex = this.option("tabindex") || 0;
            var _rowsView = this.getView("rowsView");
            $row = (0, _renderer.default)(_rowsView._getRowElements($tableElement).eq(focusedRowIndex));
            $row.addClass(ROW_FOCUSED_CLASS).attr("tabindex", tabIndex)
        }
        return $row
    };
    return FocusController
}(_m_modules.default.ViewController);
exports.FocusController = FocusController;
var keyboardNavigation = function(Base) {
    return function(_Base) {
        _inheritsLoose(FocusKeyboardNavigationExtender, _Base);

        function FocusKeyboardNavigationExtender() {
            return _Base.apply(this, arguments) || this
        }
        var _proto2 = FocusKeyboardNavigationExtender.prototype;
        _proto2.init = function() {
            var rowIndex = this.option("focusedRowIndex");
            var columnIndex = this.option("focusedColumnIndex");
            this.createAction("onFocusedRowChanging", {
                excludeValidators: ["disabled", "readOnly"]
            });
            this.createAction("onFocusedRowChanged", {
                excludeValidators: ["disabled", "readOnly"]
            });
            this.createAction("onFocusedCellChanging", {
                excludeValidators: ["disabled", "readOnly"]
            });
            this.createAction("onFocusedCellChanged", {
                excludeValidators: ["disabled", "readOnly"]
            });
            _Base.prototype.init.call(this);
            this.setRowFocusType();
            this._focusedCellPosition = {};
            if ((0, _type.isDefined)(rowIndex) && rowIndex >= 0) {
                this._focusedCellPosition.rowIndex = rowIndex
            }
            if ((0, _type.isDefined)(columnIndex) && columnIndex >= 0) {
                this._focusedCellPosition.columnIndex = columnIndex
            }
        };
        _proto2.setFocusedRowIndex = function(rowIndex) {
            _Base.prototype.setFocusedRowIndex.call(this, rowIndex);
            this.option("focusedRowIndex", rowIndex)
        };
        _proto2.setFocusedColumnIndex = function(columnIndex) {
            _Base.prototype.setFocusedColumnIndex.call(this, columnIndex);
            this.option("focusedColumnIndex", columnIndex)
        };
        _proto2._escapeKeyHandler = function(eventArgs, isEditing) {
            if (isEditing || !this.option("focusedRowEnabled")) {
                return _Base.prototype._escapeKeyHandler.call(this, eventArgs, isEditing)
            }
            if (this.isCellFocusType()) {
                this.setRowFocusType();
                this._focus(this._getCellElementFromTarget(eventArgs.originalEvent.target), true);
                return true
            }
            return false
        };
        _proto2._updateFocusedCellPosition = function($cell, direction) {
            var position = _Base.prototype._updateFocusedCellPosition.call(this, $cell, direction);
            if (position && position.columnIndex >= 0) {
                this._fireFocusedCellChanged($cell)
            }
            return position
        };
        return FocusKeyboardNavigationExtender
    }(Base)
};
var editorFactory = function(Base) {
    return function(_Base2) {
        _inheritsLoose(FocusEditorFactoryExtender, _Base2);

        function FocusEditorFactoryExtender() {
            return _Base2.apply(this, arguments) || this
        }
        var _proto3 = FocusEditorFactoryExtender.prototype;
        _proto3.renderFocusOverlay = function($element, isHideBorder) {
            var _a;
            var focusedRowEnabled = this.option("focusedRowEnabled");
            var $cell;
            if (!focusedRowEnabled || !(null === (_a = this._keyboardNavigationController) || void 0 === _a ? void 0 : _a.isRowFocusType()) || this._editingController.isEditing()) {
                _Base2.prototype.renderFocusOverlay.call(this, $element, isHideBorder)
            } else if (focusedRowEnabled) {
                var isRowElement = "row" === this._keyboardNavigationController._getElementType($element);
                if (isRowElement && !$element.hasClass(ROW_FOCUSED_CLASS)) {
                    $cell = this._keyboardNavigationController.getFirstValidCellInRow($element);
                    this._keyboardNavigationController.focus($cell)
                }
            }
        };
        return FocusEditorFactoryExtender
    }(Base)
};
var columns = function(Base) {
    return function(_Base3) {
        _inheritsLoose(FocusColumnsExtender, _Base3);

        function FocusColumnsExtender() {
            return _Base3.apply(this, arguments) || this
        }
        var _proto4 = FocusColumnsExtender.prototype;
        _proto4.getSortDataSourceParameters = function(_, sortByKey) {
            var _this7 = this;
            var result = _Base3.prototype.getSortDataSourceParameters.apply(this, arguments);
            var dataSource = this._dataController._dataSource;
            var store = this._dataController.store();
            var key = store && store.key();
            var remoteOperations = dataSource && dataSource.remoteOperations() || {};
            var isLocalOperations = Object.keys(remoteOperations).every((function(operationName) {
                return !remoteOperations[operationName]
            }));
            if (key && (this.option("focusedRowEnabled") && false !== this._focusController.isAutoNavigateToFocusedRow() || sortByKey)) {
                key = Array.isArray(key) ? key : [key];
                var notSortedKeys = key.filter((function(key) {
                    return !_this7.columnOption(key, "sortOrder")
                }));
                if (notSortedKeys.length) {
                    result = result || [];
                    if (isLocalOperations) {
                        result.push({
                            selector: dataSource.getDataIndexGetter(),
                            desc: false
                        })
                    } else {
                        notSortedKeys.forEach((function(notSortedKey) {
                            return result.push({
                                selector: notSortedKey,
                                desc: false
                            })
                        }))
                    }
                }
            }
            return result
        };
        return FocusColumnsExtender
    }(Base)
};
var data = function(Base) {
    return function(_Base4) {
        _inheritsLoose(FocusDataControllerExtender, _Base4);

        function FocusDataControllerExtender() {
            return _Base4.apply(this, arguments) || this
        }
        var _proto5 = FocusDataControllerExtender.prototype;
        _proto5._applyChange = function(change) {
            if (change && "updateFocusedRow" === change.changeType) {
                return
            }
            return _Base4.prototype._applyChange.apply(this, arguments)
        };
        _proto5._fireChanged = function(e) {
            _Base4.prototype._fireChanged.call(this, e);
            if (this.option("focusedRowEnabled") && this._dataSource) {
                var isPartialUpdate = "update" === e.changeType && e.repaintChangesOnly;
                var isPartialUpdateWithDeleting = isPartialUpdate && e.changeTypes && e.changeTypes.indexOf("remove") >= 0;
                if ("refresh" === e.changeType && e.items.length || isPartialUpdateWithDeleting) {
                    this._updatePageIndexes();
                    this._updateFocusedRow(e)
                } else if ("append" === e.changeType || "prepend" === e.changeType) {
                    this._updatePageIndexes()
                } else if ("update" === e.changeType && e.repaintChangesOnly) {
                    this._updateFocusedRow(e)
                }
            }
        };
        _proto5._updatePageIndexes = function() {
            var prevRenderingPageIndex = this._lastRenderingPageIndex || 0;
            var renderingPageIndex = this._rowsScrollController ? this._rowsScrollController.pageIndex() : 0;
            this._lastRenderingPageIndex = renderingPageIndex;
            this._isPagingByRendering = renderingPageIndex !== prevRenderingPageIndex
        };
        _proto5.isPagingByRendering = function() {
            return this._isPagingByRendering
        };
        _proto5._updateFocusedRow = function(e) {
            var _this8 = this;
            var operationTypes = e.operationTypes || {};
            var reload = operationTypes.reload,
                fullReload = operationTypes.fullReload,
                pageIndex = operationTypes.pageIndex,
                paging = operationTypes.paging;
            var isVirtualScrolling = this._keyboardNavigationController._isVirtualScrolling();
            var pagingWithoutVirtualScrolling = paging && !isVirtualScrolling;
            var focusedRowKey = this.option("focusedRowKey");
            var isAutoNavigate = this._focusController.isAutoNavigateToFocusedRow();
            var isReload = reload && false === pageIndex;
            if (isReload && !fullReload && (0, _type.isDefined)(focusedRowKey)) {
                this._focusController._navigateToRow(focusedRowKey, true).done((function(focusedRowIndex) {
                    if (focusedRowIndex < 0) {
                        _this8._focusController._focusRowByIndex(void 0, operationTypes)
                    }
                }))
            } else if (pagingWithoutVirtualScrolling && isAutoNavigate) {
                var rowIndexByKey = this.getRowIndexByKey(focusedRowKey);
                var focusedRowIndex = this.option("focusedRowIndex");
                var isValidRowIndexByKey = rowIndexByKey >= 0;
                var isValidFocusedRowIndex = focusedRowIndex >= 0;
                var isSameRowIndex = focusedRowIndex === rowIndexByKey;
                if (isValidFocusedRowIndex && (isSameRowIndex || !isValidRowIndexByKey)) {
                    this._focusController._focusRowByIndex(focusedRowIndex, operationTypes)
                }
            } else if (pagingWithoutVirtualScrolling && !isAutoNavigate && this.getRowIndexByKey(focusedRowKey) < 0) {
                this.option("focusedRowIndex", -1)
            } else if (operationTypes.fullReload) {
                this._focusController._focusRowByKeyOrIndex()
            }
        };
        _proto5.getPageIndexByKey = function(key) {
            var that = this;
            var d = new _deferred.Deferred;
            that.getGlobalRowIndexByKey(key).done((function(globalIndex) {
                d.resolve(globalIndex >= 0 ? Math.floor(globalIndex / that.pageSize()) : -1)
            })).fail(d.reject);
            return d.promise()
        };
        _proto5.getGlobalRowIndexByKey = function(key) {
            if (this._dataSource.group()) {
                return this._calculateGlobalRowIndexByGroupedData(key)
            }
            return this._calculateGlobalRowIndexByFlatData(key)
        };
        _proto5._calculateGlobalRowIndexByFlatData = function(key, groupFilter, useGroup) {
            var that = this;
            var deferred = new _deferred.Deferred;
            var dataSource = that._dataSource;
            if (Array.isArray(key) || (0, _m_editing_utils.isNewRowTempKey)(key)) {
                return deferred.resolve(-1).promise()
            }
            var filter = that._generateFilterByKey(key);
            dataSource.load({
                filter: that._concatWithCombinedFilter(filter),
                skip: 0,
                take: 1
            }).done((function(data) {
                if (data.length > 0) {
                    filter = that._generateOperationFilterByKey(key, data[0], useGroup);
                    dataSource.load({
                        filter: that._concatWithCombinedFilter(filter, groupFilter),
                        skip: 0,
                        take: 1,
                        requireTotalCount: true
                    }).done((function(_, extra) {
                        deferred.resolve(extra.totalCount)
                    }))
                } else {
                    deferred.resolve(-1)
                }
            }));
            return deferred.promise()
        };
        _proto5._concatWithCombinedFilter = function(filter, groupFilter) {
            var combinedFilter = this.getCombinedFilter();
            return _m_utils.default.combineFilters([filter, combinedFilter, groupFilter])
        };
        _proto5._generateBooleanFilter = function(selector, value, sortInfo) {
            var desc = sortInfo.desc;
            switch (true) {
                case false === value && desc:
                    return [selector, "=", true];
                case false === value && !desc:
                    return [selector, "=", null];
                case true === value && !desc:
                case !(0, _type.isBoolean)(value) && desc:
                    return [selector, "<>", value];
                default:
                    return
            }
        };
        _proto5._generateOperationFilterByKey = function(key, rowData, useGroup) {
            var that = this;
            var dateSerializationFormat = that.option("dateSerializationFormat");
            var isRemoteFiltering = that._dataSource.remoteOperations().filtering;
            var isRemoteSorting = that._dataSource.remoteOperations().sorting;
            var filter = that._generateFilterByKey(key, "<");
            var sort = that._columnsController.getSortDataSourceParameters(!isRemoteFiltering, true);
            if (useGroup) {
                var group = that._columnsController.getGroupDataSourceParameters(!isRemoteFiltering);
                if (group) {
                    sort = sort ? group.concat(sort) : group
                }
            }
            if (sort) {
                sort.slice().reverse().forEach((function(sortInfo) {
                    var selector = sortInfo.selector,
                        desc = sortInfo.desc,
                        compare = sortInfo.compare;
                    var _UiGridCoreFocusUtils = _m_focus_utils.UiGridCoreFocusUtils.getSortFilterValue(sortInfo, rowData, {
                            isRemoteFiltering: isRemoteFiltering,
                            dateSerializationFormat: dateSerializationFormat,
                            getSelector: function(selector) {
                                return that._columnsController.columnOption(selector, "selector")
                            }
                        }),
                        getter = _UiGridCoreFocusUtils.getter,
                        rawValue = _UiGridCoreFocusUtils.rawValue,
                        safeValue = _UiGridCoreFocusUtils.safeValue;
                    filter = [
                        [selector, "=", safeValue], "and", filter
                    ];
                    if (null === rawValue || (0, _type.isBoolean)(rawValue)) {
                        var booleanFilter = that._generateBooleanFilter(selector, safeValue, desc);
                        if (booleanFilter) {
                            filter = [booleanFilter, "or", filter]
                        }
                    } else {
                        var filterOperation = desc ? ">" : "<";
                        var sortFilter;
                        if (compare && !isRemoteSorting) {
                            sortFilter = function(data) {
                                if ("<" === filterOperation) {
                                    return compare(rawValue, getter(data)) >= 1
                                }
                                return compare(rawValue, getter(data)) <= -1
                            }
                        } else {
                            sortFilter = [selector, filterOperation, safeValue];
                            if (!desc) {
                                sortFilter = [sortFilter, "or", [selector, "=", null]]
                            }
                        }
                        filter = [sortFilter, "or", filter]
                    }
                }))
            }
            return filter
        };
        _proto5._generateFilterByKey = function(key, operation) {
            var dataSourceKey = this._dataSource.key();
            var filter = [];
            if (!operation) {
                operation = "="
            }
            if (Array.isArray(dataSourceKey)) {
                for (var i = 0; i < dataSourceKey.length; ++i) {
                    var keyPart = key[dataSourceKey[i]];
                    if (keyPart) {
                        if (filter.length > 0) {
                            filter.push("and")
                        }
                        filter.push([dataSourceKey[i], operation, keyPart])
                    }
                }
            } else {
                filter = [dataSourceKey, operation, key]
            }
            return filter
        };
        _proto5._getLastItemIndex = function() {
            return this.items(true).length - 1
        };
        return FocusDataControllerExtender
    }(Base)
};
var editing = function(Base) {
    return function(_Base5) {
        _inheritsLoose(FocusEditingControllerExtender, _Base5);

        function FocusEditingControllerExtender() {
            return _Base5.apply(this, arguments) || this
        }
        var _proto6 = FocusEditingControllerExtender.prototype;
        _proto6._deleteRowCore = function(rowIndex) {
            var _this9 = this;
            var deferred = _Base5.prototype._deleteRowCore.apply(this, arguments);
            var rowKey = this._dataController.getKeyByRowIndex(rowIndex);
            deferred.done((function() {
                var rowIndex = _this9._dataController.getRowIndexByKey(rowKey);
                var visibleRows = _this9._dataController.getVisibleRows();
                if (-1 === rowIndex && !visibleRows.length) {
                    _this9._focusController._resetFocusedRow()
                }
            }))
        };
        return FocusEditingControllerExtender
    }(Base)
};
var rowsView = function(Base) {
    return function(_Base6) {
        _inheritsLoose(RowsViewFocusController, _Base6);

        function RowsViewFocusController() {
            return _Base6.apply(this, arguments) || this
        }
        var _proto7 = RowsViewFocusController.prototype;
        _proto7._createRow = function(row) {
            var $row = _Base6.prototype._createRow.apply(this, arguments);
            if (this.option("focusedRowEnabled") && row) {
                if (this._focusController.isRowFocused(row.key)) {
                    $row.addClass(ROW_FOCUSED_CLASS)
                }
            }
            return $row
        };
        _proto7._checkRowKeys = function(options) {
            _Base6.prototype._checkRowKeys.apply(this, arguments);
            if (this.option("focusedRowEnabled") && this.option("dataSource")) {
                var store = this._dataController.store();
                if (store && !store.key()) {
                    this._dataController.fireError("E1042", "Row focusing")
                }
            }
        };
        _proto7._update = function(change) {
            if ("updateFocusedRow" === change.changeType) {
                if (this.option("focusedRowEnabled")) {
                    this._focusController.updateFocusedRow(change)
                }
            } else {
                _Base6.prototype._update.call(this, change)
            }
        };
        _proto7.updateFocusElementTabIndex = function($cellElements, preventScroll) {
            if (this.option("focusedRowEnabled")) {
                this._setFocusedRowElementTabIndex(preventScroll)
            } else {
                _Base6.prototype.updateFocusElementTabIndex.call(this, $cellElements)
            }
        };
        _proto7._setFocusedRowElementTabIndex = function(preventScroll) {
            var _this10 = this;
            var _a;
            var focusedRowKey = this.option("focusedRowKey");
            var tabIndex = null !== (_a = this.option("tabIndex")) && void 0 !== _a ? _a : 0;
            var columnsController = this._columnsController;
            var rowIndex = this._dataController.getRowIndexByKey(focusedRowKey);
            var columnIndex = this.option("focusedColumnIndex");
            var $row = this._findRowElementForTabIndex();
            var dataSource = this._dataController.dataSource();
            var operationTypes = null === dataSource || void 0 === dataSource ? void 0 : dataSource.operationTypes();
            var isPaging = !operationTypes || operationTypes.paging;
            if (!(0, _type.isDefined)(this._scrollToFocusOnResize)) {
                this._scrollToFocusOnResize = function() {
                    _this10.scrollToElementVertically(_this10._findRowElementForTabIndex());
                    _this10.resizeCompleted.remove(_this10._scrollToFocusOnResize)
                }
            }
            $row.attr("tabIndex", tabIndex);
            var rowIndexFromOption = this.option("focusedRowIndex") - this._dataController.getRowIndexOffset(true);
            if (!isPaging && rowIndex < 0 && rowIndexFromOption >= 0) {
                this._focusController.updateFocusedRow({
                    focusedRowIndex: rowIndexFromOption,
                    preventScroll: preventScroll
                })
            }
            if (rowIndex >= 0 && !preventScroll) {
                if (columnIndex < 0) {
                    columnIndex = 0
                }
                rowIndex += this._dataController.getRowIndexOffset();
                columnIndex += columnsController.getColumnIndexOffset();
                this._keyboardNavigationController.setFocusedCellPosition(rowIndex, columnIndex);
                if (this._focusController.isAutoNavigateToFocusedRow()) {
                    if (!isPaging && !this._dataController.isPagingByRendering()) {
                        this.resizeCompleted.remove(this._scrollToFocusOnResize);
                        this.resizeCompleted.add(this._scrollToFocusOnResize)
                    }
                }
            }
        };
        _proto7._findRowElementForTabIndex = function() {
            var focusedRowKey = this.option("focusedRowKey");
            var rowIndex = this._dataController.getRowIndexByKey(focusedRowKey);
            return (0, _renderer.default)(this.getRowElement(rowIndex >= 0 ? rowIndex : 0))
        };
        _proto7.scrollToRowElement = function(key) {
            var rowIndex = this._dataController.getRowIndexByKey(key);
            var $row = (0, _renderer.default)(this.getRow(rowIndex));
            return this.scrollToElementVertically($row)
        };
        _proto7.scrollToElementVertically = function($row) {
            var scrollable = this.getScrollable();
            if (scrollable && $row.length) {
                var position = scrollable.getScrollElementPosition($row, "vertical");
                return this.scrollTopPosition(position)
            }
            return (new _deferred.Deferred).resolve()
        };
        _proto7.scrollTopPosition = function(scrollTop) {
            var d = new _deferred.Deferred;
            var scrollable = this.getScrollable();
            if (scrollable) {
                var currentScrollTop = scrollable.scrollTop();
                if (scrollTop !== currentScrollTop) {
                    scrollable.on("scroll", (function scrollHandler() {
                        scrollable.off("scroll", scrollHandler);
                        d.resolve()
                    }));
                    this._dataController.resetFilterApplying();
                    scrollable.scrollTo({
                        top: scrollTop
                    });
                    return d.promise()
                }
            }
            return d.resolve()
        };
        return RowsViewFocusController
    }(Base)
};
var focusModule = {
    defaultOptions: function() {
        return {
            focusedRowEnabled: false,
            autoNavigateToFocusedRow: true,
            focusedRowKey: null,
            focusedRowIndex: -1,
            focusedColumnIndex: -1
        }
    },
    controllers: {
        focus: FocusController
    },
    extenders: {
        controllers: {
            keyboardNavigation: keyboardNavigation,
            editorFactory: editorFactory,
            columns: columns,
            data: data,
            editing: editing
        },
        views: {
            rowsView: rowsView
        }
    }
};
exports.focusModule = focusModule;
