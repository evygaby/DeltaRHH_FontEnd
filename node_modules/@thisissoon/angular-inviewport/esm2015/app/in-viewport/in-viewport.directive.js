/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, ElementRef, HostBinding, EventEmitter, Output, Inject, Input } from '@angular/core';
import { WINDOW } from '../window/window-token';
/**
 * A simple lightweight library for Angular with that detects when an
 * element is within the browsers viewport and adds a `in-viewport` or
 * `not-in-viewport` class to the element.
 *
 * \@example
 * ```html
 * <p
 *  class="foo"
 *  snInViewport
 *  (inViewportChange)="myEventHandler($event)">
 *  Amet tempor excepteur occaecat nulla.
 * </p>
 * ```
 */
// @dynamic
export class InViewportDirective {
    /**
     * @param {?} el
     * @param {?} window
     */
    constructor(el, window) {
        this.el = el;
        this.window = window;
        this.inViewportChange = new EventEmitter();
        this.hasIntersectionObserver = this.intersectionObserverFeatureDetection();
    }
    /**
     * @return {?}
     */
    get isInViewport() {
        return this.inViewport;
    }
    /**
     * @return {?}
     */
    get isNotInViewport() {
        return !this.inViewport;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.hasIntersectionObserver) {
            this.inViewport = true;
            this.inViewportChange.emit(this.inViewport);
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.hasIntersectionObserver) {
            /** @type {?} */
            const IntersectionObserver = this.window['IntersectionObserver'];
            this.observer = new IntersectionObserver(this.intersectionObserverCallback.bind(this), this.inViewportOptions);
            this.observer.observe(this.el.nativeElement);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.observer) {
            this.observer.unobserve(this.el.nativeElement);
        }
    }
    /**
     * @param {?} entries
     * @return {?}
     */
    intersectionObserverCallback(entries) {
        entries.forEach((/**
         * @param {?} entry
         * @return {?}
         */
        entry => {
            if (this.inViewport === entry.isIntersecting)
                return;
            this.inViewport = entry.isIntersecting;
            this.inViewportChange.emit(this.inViewport);
        }));
    }
    /**
     * @private
     * @return {?}
     */
    intersectionObserverFeatureDetection() {
        // Exits early if all IntersectionObserver and IntersectionObserverEntry
        // features are natively supported.
        if ('IntersectionObserver' in this.window &&
            'IntersectionObserverEntry' in this.window) {
            // Minimal polyfill for Edge 15's lack of `isIntersecting`
            // See: https://github.com/w3c/IntersectionObserver/issues/211
            if (!('isIntersecting' in
                this.window['IntersectionObserverEntry']['prototype'])) {
                Object.defineProperty(this.window['IntersectionObserverEntry']['prototype'], 'isIntersecting', {
                    get: (/**
                     * @return {?}
                     */
                    function () {
                        return this.intersectionRatio > 0;
                    })
                });
            }
            return true;
        }
        return false;
    }
}
InViewportDirective.decorators = [
    { type: Directive, args: [{
                selector: '[snInViewport]',
                exportAs: 'snInViewport'
            },] }
];
/** @nocollapse */
InViewportDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] }
];
InViewportDirective.propDecorators = {
    inViewportOptions: [{ type: Input }],
    inViewportChange: [{ type: Output }],
    isInViewport: [{ type: HostBinding, args: ['class.sn-viewport--in',] }],
    isNotInViewport: [{ type: HostBinding, args: ['class.sn-viewport--out',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    InViewportDirective.prototype.inViewport;
    /**
     * @type {?}
     * @private
     */
    InViewportDirective.prototype.hasIntersectionObserver;
    /** @type {?} */
    InViewportDirective.prototype.inViewportOptions;
    /** @type {?} */
    InViewportDirective.prototype.inViewportChange;
    /** @type {?} */
    InViewportDirective.prototype.observer;
    /**
     * @type {?}
     * @private
     */
    InViewportDirective.prototype.el;
    /**
     * @type {?}
     * @private
     */
    InViewportDirective.prototype.window;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW4tdmlld3BvcnQuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRoaXNpc3Nvb24vYW5ndWxhci1pbnZpZXdwb3J0LyIsInNvdXJjZXMiOlsiYXBwL2luLXZpZXdwb3J0L2luLXZpZXdwb3J0LmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxVQUFVLEVBQ1YsV0FBVyxFQUNYLFlBQVksRUFDWixNQUFNLEVBR04sTUFBTSxFQUNOLEtBQUssRUFFTixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sd0JBQXdCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JoRCxNQUFNLE9BQU8sbUJBQW1COzs7OztJQW1COUIsWUFBb0IsRUFBYyxFQUEwQixNQUFjO1FBQXRELE9BQUUsR0FBRixFQUFFLENBQVk7UUFBMEIsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQWIxRSxxQkFBZ0IsR0FBRyxJQUFJLFlBQVksRUFBVyxDQUFDO1FBYzdDLElBQUksQ0FBQyx1QkFBdUIsR0FBRyxJQUFJLENBQUMsb0NBQW9DLEVBQUUsQ0FBQztJQUM3RSxDQUFDOzs7O0lBWkQsSUFDSSxZQUFZO1FBQ2QsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO0lBQ3pCLENBQUM7Ozs7SUFFRCxJQUNJLGVBQWU7UUFDakIsT0FBTyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7SUFDMUIsQ0FBQzs7OztJQU1ELFFBQVE7UUFDTixJQUFJLENBQUMsSUFBSSxDQUFDLHVCQUF1QixFQUFFO1lBQ2pDLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO1lBQ3ZCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQzdDO0lBQ0gsQ0FBQzs7OztJQUVELGVBQWU7UUFDYixJQUFJLElBQUksQ0FBQyx1QkFBdUIsRUFBRTs7a0JBQzFCLG9CQUFvQixHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsc0JBQXNCLENBQUM7WUFDaEUsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLG9CQUFvQixDQUN0QyxJQUFJLENBQUMsNEJBQTRCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUM1QyxJQUFJLENBQUMsaUJBQWlCLENBQ3ZCLENBQUM7WUFFRixJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1NBQzlDO0lBQ0gsQ0FBQzs7OztJQUVELFdBQVc7UUFDVCxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDakIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsQ0FBQztTQUNoRDtJQUNILENBQUM7Ozs7O0lBRUQsNEJBQTRCLENBQUMsT0FBb0M7UUFDL0QsT0FBTyxDQUFDLE9BQU87Ozs7UUFBQyxLQUFLLENBQUMsRUFBRTtZQUN0QixJQUFJLElBQUksQ0FBQyxVQUFVLEtBQUssS0FBSyxDQUFDLGNBQWM7Z0JBQUUsT0FBTztZQUNyRCxJQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQyxjQUFjLENBQUM7WUFDdkMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDOUMsQ0FBQyxFQUFDLENBQUM7SUFDTCxDQUFDOzs7OztJQUVPLG9DQUFvQztRQUMxQyx3RUFBd0U7UUFDeEUsbUNBQW1DO1FBQ25DLElBQ0Usc0JBQXNCLElBQUksSUFBSSxDQUFDLE1BQU07WUFDckMsMkJBQTJCLElBQUksSUFBSSxDQUFDLE1BQU0sRUFDMUM7WUFDQSwwREFBMEQ7WUFDMUQsOERBQThEO1lBQzlELElBQ0UsQ0FBQyxDQUNDLGdCQUFnQjtnQkFDaEIsSUFBSSxDQUFDLE1BQU0sQ0FBQywyQkFBMkIsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUN0RCxFQUNEO2dCQUNBLE1BQU0sQ0FBQyxjQUFjLENBQ25CLElBQUksQ0FBQyxNQUFNLENBQUMsMkJBQTJCLENBQUMsQ0FBQyxXQUFXLENBQUMsRUFDckQsZ0JBQWdCLEVBQ2hCO29CQUNFLEdBQUc7OztvQkFBRTt3QkFDSCxPQUFPLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxDQUFDLENBQUM7b0JBQ3BDLENBQUMsQ0FBQTtpQkFDRixDQUNGLENBQUM7YUFDSDtZQUNELE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFDRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7OztZQXhGRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLGdCQUFnQjtnQkFDMUIsUUFBUSxFQUFFLGNBQWM7YUFDekI7Ozs7WUEvQkMsVUFBVTtZQW1EMEQsTUFBTSx1QkFBckMsTUFBTSxTQUFDLE1BQU07OztnQ0FoQmpELEtBQUs7K0JBRUwsTUFBTTsyQkFJTixXQUFXLFNBQUMsdUJBQXVCOzhCQUtuQyxXQUFXLFNBQUMsd0JBQXdCOzs7Ozs7O0lBYnJDLHlDQUE0Qjs7Ozs7SUFDNUIsc0RBQXlDOztJQUN6QyxnREFDNEM7O0lBQzVDLCtDQUMrQzs7SUFDL0MsdUNBQStCOzs7OztJQVluQixpQ0FBc0I7Ozs7O0lBQUUscUNBQXNDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBIb3N0QmluZGluZyxcbiAgRXZlbnRFbWl0dGVyLFxuICBPdXRwdXQsXG4gIE9uRGVzdHJveSxcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgSW5qZWN0LFxuICBJbnB1dCxcbiAgT25Jbml0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgV0lORE9XIH0gZnJvbSAnLi4vd2luZG93L3dpbmRvdy10b2tlbic7XG5cbi8qKlxuICogQSBzaW1wbGUgbGlnaHR3ZWlnaHQgbGlicmFyeSBmb3IgQW5ndWxhciB3aXRoIHRoYXQgZGV0ZWN0cyB3aGVuIGFuXG4gKiBlbGVtZW50IGlzIHdpdGhpbiB0aGUgYnJvd3NlcnMgdmlld3BvcnQgYW5kIGFkZHMgYSBgaW4tdmlld3BvcnRgIG9yXG4gKiBgbm90LWluLXZpZXdwb3J0YCBjbGFzcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgaHRtbFxuICogPHBcbiAqICBjbGFzcz1cImZvb1wiXG4gKiAgc25JblZpZXdwb3J0XG4gKiAgKGluVmlld3BvcnRDaGFuZ2UpPVwibXlFdmVudEhhbmRsZXIoJGV2ZW50KVwiPlxuICogIEFtZXQgdGVtcG9yIGV4Y2VwdGV1ciBvY2NhZWNhdCBudWxsYS5cbiAqIDwvcD5cbiAqIGBgYFxuICovXG4vLyBAZHluYW1pY1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW3NuSW5WaWV3cG9ydF0nLFxuICBleHBvcnRBczogJ3NuSW5WaWV3cG9ydCdcbn0pXG5leHBvcnQgY2xhc3MgSW5WaWV3cG9ydERpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSwgT25Jbml0IHtcbiAgcHJpdmF0ZSBpblZpZXdwb3J0OiBib29sZWFuO1xuICBwcml2YXRlIGhhc0ludGVyc2VjdGlvbk9ic2VydmVyOiBib29sZWFuO1xuICBASW5wdXQoKVxuICBpblZpZXdwb3J0T3B0aW9uczogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0O1xuICBAT3V0cHV0KClcbiAgaW5WaWV3cG9ydENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcbiAgb2JzZXJ2ZXI6IEludGVyc2VjdGlvbk9ic2VydmVyO1xuXG4gIEBIb3N0QmluZGluZygnY2xhc3Muc24tdmlld3BvcnQtLWluJylcbiAgZ2V0IGlzSW5WaWV3cG9ydCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pblZpZXdwb3J0O1xuICB9XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5zbi12aWV3cG9ydC0tb3V0JylcbiAgZ2V0IGlzTm90SW5WaWV3cG9ydCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMuaW5WaWV3cG9ydDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsIEBJbmplY3QoV0lORE9XKSBwcml2YXRlIHdpbmRvdzogV2luZG93KSB7XG4gICAgdGhpcy5oYXNJbnRlcnNlY3Rpb25PYnNlcnZlciA9IHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXJGZWF0dXJlRGV0ZWN0aW9uKCk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICBpZiAoIXRoaXMuaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIHRoaXMuaW5WaWV3cG9ydCA9IHRydWU7XG4gICAgICB0aGlzLmluVmlld3BvcnRDaGFuZ2UuZW1pdCh0aGlzLmluVmlld3BvcnQpO1xuICAgIH1cbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICBpZiAodGhpcy5oYXNJbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgY29uc3QgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSB0aGlzLndpbmRvd1snSW50ZXJzZWN0aW9uT2JzZXJ2ZXInXTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXJDYWxsYmFjay5iaW5kKHRoaXMpLFxuICAgICAgICB0aGlzLmluVmlld3BvcnRPcHRpb25zXG4gICAgICApO1xuXG4gICAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUodGhpcy5lbC5uYXRpdmVFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5vYnNlcnZlcikge1xuICAgICAgdGhpcy5vYnNlcnZlci51bm9ic2VydmUodGhpcy5lbC5uYXRpdmVFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICBpbnRlcnNlY3Rpb25PYnNlcnZlckNhbGxiYWNrKGVudHJpZXM6IEludGVyc2VjdGlvbk9ic2VydmVyRW50cnlbXSkge1xuICAgIGVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICBpZiAodGhpcy5pblZpZXdwb3J0ID09PSBlbnRyeS5pc0ludGVyc2VjdGluZykgcmV0dXJuO1xuICAgICAgdGhpcy5pblZpZXdwb3J0ID0gZW50cnkuaXNJbnRlcnNlY3Rpbmc7XG4gICAgICB0aGlzLmluVmlld3BvcnRDaGFuZ2UuZW1pdCh0aGlzLmluVmlld3BvcnQpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBpbnRlcnNlY3Rpb25PYnNlcnZlckZlYXR1cmVEZXRlY3Rpb24oKSB7XG4gICAgLy8gRXhpdHMgZWFybHkgaWYgYWxsIEludGVyc2VjdGlvbk9ic2VydmVyIGFuZCBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5XG4gICAgLy8gZmVhdHVyZXMgYXJlIG5hdGl2ZWx5IHN1cHBvcnRlZC5cbiAgICBpZiAoXG4gICAgICAnSW50ZXJzZWN0aW9uT2JzZXJ2ZXInIGluIHRoaXMud2luZG93ICYmXG4gICAgICAnSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeScgaW4gdGhpcy53aW5kb3dcbiAgICApIHtcbiAgICAgIC8vIE1pbmltYWwgcG9seWZpbGwgZm9yIEVkZ2UgMTUncyBsYWNrIG9mIGBpc0ludGVyc2VjdGluZ2BcbiAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3czYy9JbnRlcnNlY3Rpb25PYnNlcnZlci9pc3N1ZXMvMjExXG4gICAgICBpZiAoXG4gICAgICAgICEoXG4gICAgICAgICAgJ2lzSW50ZXJzZWN0aW5nJyBpblxuICAgICAgICAgIHRoaXMud2luZG93WydJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5J11bJ3Byb3RvdHlwZSddXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgdGhpcy53aW5kb3dbJ0ludGVyc2VjdGlvbk9ic2VydmVyRW50cnknXVsncHJvdG90eXBlJ10sXG4gICAgICAgICAgJ2lzSW50ZXJzZWN0aW5nJyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3Rpb25SYXRpbyA+IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIl19