import { InjectionToken, Directive, ElementRef, HostBinding, EventEmitter, Output, Inject, Input, NgModule } from '@angular/core';
import { __assign } from 'tslib';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var WINDOW = new InjectionToken('WINDOW', {
    providedIn: 'root',
    factory: (/**
     * @return {?}
     */
    function () { return window; })
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * A simple lightweight library for Angular with that detects when an
 * element is within the browsers viewport and adds a `in-viewport` or
 * `not-in-viewport` class to the element.
 *
 * \@example
 * ```html
 * <p
 *  class="foo"
 *  snInViewport
 *  (inViewportChange)="myEventHandler($event)">
 *  Amet tempor excepteur occaecat nulla.
 * </p>
 * ```
 */
// @dynamic
var InViewportDirective = /** @class */ (function () {
    function InViewportDirective(el, window) {
        this.el = el;
        this.window = window;
        this.inViewportChange = new EventEmitter();
        this.hasIntersectionObserver = this.intersectionObserverFeatureDetection();
    }
    Object.defineProperty(InViewportDirective.prototype, "isInViewport", {
        get: /**
         * @return {?}
         */
        function () {
            return this.inViewport;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InViewportDirective.prototype, "isNotInViewport", {
        get: /**
         * @return {?}
         */
        function () {
            return !this.inViewport;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    InViewportDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (!this.hasIntersectionObserver) {
            this.inViewport = true;
            this.inViewportChange.emit(this.inViewport);
        }
    };
    /**
     * @return {?}
     */
    InViewportDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (this.hasIntersectionObserver) {
            /** @type {?} */
            var IntersectionObserver_1 = this.window['IntersectionObserver'];
            this.observer = new IntersectionObserver_1(this.intersectionObserverCallback.bind(this), this.inViewportOptions);
            this.observer.observe(this.el.nativeElement);
        }
    };
    /**
     * @return {?}
     */
    InViewportDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.observer) {
            this.observer.unobserve(this.el.nativeElement);
        }
    };
    /**
     * @param {?} entries
     * @return {?}
     */
    InViewportDirective.prototype.intersectionObserverCallback = /**
     * @param {?} entries
     * @return {?}
     */
    function (entries) {
        var _this = this;
        entries.forEach((/**
         * @param {?} entry
         * @return {?}
         */
        function (entry) {
            if (_this.inViewport === entry.isIntersecting)
                return;
            _this.inViewport = entry.isIntersecting;
            _this.inViewportChange.emit(_this.inViewport);
        }));
    };
    /**
     * @private
     * @return {?}
     */
    InViewportDirective.prototype.intersectionObserverFeatureDetection = /**
     * @private
     * @return {?}
     */
    function () {
        // Exits early if all IntersectionObserver and IntersectionObserverEntry
        // features are natively supported.
        if ('IntersectionObserver' in this.window &&
            'IntersectionObserverEntry' in this.window) {
            // Minimal polyfill for Edge 15's lack of `isIntersecting`
            // See: https://github.com/w3c/IntersectionObserver/issues/211
            if (!('isIntersecting' in
                this.window['IntersectionObserverEntry']['prototype'])) {
                Object.defineProperty(this.window['IntersectionObserverEntry']['prototype'], 'isIntersecting', {
                    get: (/**
                     * @return {?}
                     */
                    function () {
                        return this.intersectionRatio > 0;
                    })
                });
            }
            return true;
        }
        return false;
    };
    InViewportDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[snInViewport]',
                    exportAs: 'snInViewport'
                },] }
    ];
    /** @nocollapse */
    InViewportDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] }
    ]; };
    InViewportDirective.propDecorators = {
        inViewportOptions: [{ type: Input }],
        inViewportChange: [{ type: Output }],
        isInViewport: [{ type: HostBinding, args: ['class.sn-viewport--in',] }],
        isNotInViewport: [{ type: HostBinding, args: ['class.sn-viewport--out',] }]
    };
    return InViewportDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var WINDOW_MOCK_WITHOUT_INTERSECTION_OBSERVER = {
    closed: null,
    defaultStatus: null,
    document: null,
    frameElement: null,
    frames: null,
    history: null,
    innerHeight: null,
    innerWidth: null,
    length: null,
    localStorage: null,
    location: null,
    name: null,
    navigator: null,
    opener: null,
    outerHeight: null,
    outerWidth: null,
    pageXOffset: null,
    pageYOffset: null,
    parent: null,
    screen: null,
    screenLeft: null,
    screenTop: null,
    screenX: null,
    screenY: null,
    sessionStorage: null,
    scrollX: null,
    scrollY: null,
    self: null,
    status: null,
    top: null,
    addEventListener: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    alert: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    atob: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    blur: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    btoa: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    clearInterval: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    clearTimeout: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    close: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    confirm: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    focus: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    getComputedStyle: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    getSelection: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    matchMedia: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    moveBy: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    moveTo: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    open: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    print: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    prompt: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    resizeBy: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    resizeTo: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    removeEventListener: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    scroll: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    scrollBy: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    scrollTo: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    setInterval: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    setTimeout: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    }),
    stop: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    })
};
/** @type {?} */
var WINDOW_MOCK = __assign({}, WINDOW_MOCK_WITHOUT_INTERSECTION_OBSERVER, { IntersectionObserver: (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.observe = (/**
         * @return {?}
         */
        function () { return null; });
        this.unobserve = (/**
         * @return {?}
         */
        function () { return null; });
    }), IntersectionObserverEntry: /** @class */ (function () {
        function IntersectionObserverEntryMock() {
        }
        return IntersectionObserverEntryMock;
    }()) });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * A simple lightweight library for Angular with other dependencies
 * that detects when an element is within the browsers viewport and adds a
 * sn-viewport--in or sn-viewport--out class to the element.
 */
var InViewportModule = /** @class */ (function () {
    function InViewportModule() {
    }
    /**
     * @return {?}
     */
    InViewportModule.forServer = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: InViewportModule,
            providers: [{ provide: WINDOW, useValue: WINDOW_MOCK }]
        };
    };
    InViewportModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [InViewportDirective],
                    exports: [InViewportDirective]
                },] }
    ];
    return InViewportModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { InViewportModule, InViewportDirective, WINDOW_MOCK, WINDOW };

//# sourceMappingURL=thisissoon-angular-inviewport.js.map