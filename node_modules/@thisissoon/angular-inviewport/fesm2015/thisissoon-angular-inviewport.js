import { InjectionToken, Directive, ElementRef, HostBinding, EventEmitter, Output, Inject, Input, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const WINDOW = new InjectionToken('WINDOW', {
    providedIn: 'root',
    factory: (/**
     * @return {?}
     */
    () => window)
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * A simple lightweight library for Angular with that detects when an
 * element is within the browsers viewport and adds a `in-viewport` or
 * `not-in-viewport` class to the element.
 *
 * \@example
 * ```html
 * <p
 *  class="foo"
 *  snInViewport
 *  (inViewportChange)="myEventHandler($event)">
 *  Amet tempor excepteur occaecat nulla.
 * </p>
 * ```
 */
// @dynamic
class InViewportDirective {
    /**
     * @param {?} el
     * @param {?} window
     */
    constructor(el, window) {
        this.el = el;
        this.window = window;
        this.inViewportChange = new EventEmitter();
        this.hasIntersectionObserver = this.intersectionObserverFeatureDetection();
    }
    /**
     * @return {?}
     */
    get isInViewport() {
        return this.inViewport;
    }
    /**
     * @return {?}
     */
    get isNotInViewport() {
        return !this.inViewport;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.hasIntersectionObserver) {
            this.inViewport = true;
            this.inViewportChange.emit(this.inViewport);
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.hasIntersectionObserver) {
            /** @type {?} */
            const IntersectionObserver = this.window['IntersectionObserver'];
            this.observer = new IntersectionObserver(this.intersectionObserverCallback.bind(this), this.inViewportOptions);
            this.observer.observe(this.el.nativeElement);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.observer) {
            this.observer.unobserve(this.el.nativeElement);
        }
    }
    /**
     * @param {?} entries
     * @return {?}
     */
    intersectionObserverCallback(entries) {
        entries.forEach((/**
         * @param {?} entry
         * @return {?}
         */
        entry => {
            if (this.inViewport === entry.isIntersecting)
                return;
            this.inViewport = entry.isIntersecting;
            this.inViewportChange.emit(this.inViewport);
        }));
    }
    /**
     * @private
     * @return {?}
     */
    intersectionObserverFeatureDetection() {
        // Exits early if all IntersectionObserver and IntersectionObserverEntry
        // features are natively supported.
        if ('IntersectionObserver' in this.window &&
            'IntersectionObserverEntry' in this.window) {
            // Minimal polyfill for Edge 15's lack of `isIntersecting`
            // See: https://github.com/w3c/IntersectionObserver/issues/211
            if (!('isIntersecting' in
                this.window['IntersectionObserverEntry']['prototype'])) {
                Object.defineProperty(this.window['IntersectionObserverEntry']['prototype'], 'isIntersecting', {
                    get: (/**
                     * @return {?}
                     */
                    function () {
                        return this.intersectionRatio > 0;
                    })
                });
            }
            return true;
        }
        return false;
    }
}
InViewportDirective.decorators = [
    { type: Directive, args: [{
                selector: '[snInViewport]',
                exportAs: 'snInViewport'
            },] }
];
/** @nocollapse */
InViewportDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] }
];
InViewportDirective.propDecorators = {
    inViewportOptions: [{ type: Input }],
    inViewportChange: [{ type: Output }],
    isInViewport: [{ type: HostBinding, args: ['class.sn-viewport--in',] }],
    isNotInViewport: [{ type: HostBinding, args: ['class.sn-viewport--out',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const WINDOW_MOCK_WITHOUT_INTERSECTION_OBSERVER = {
    closed: null,
    defaultStatus: null,
    document: null,
    frameElement: null,
    frames: null,
    history: null,
    innerHeight: null,
    innerWidth: null,
    length: null,
    localStorage: null,
    location: null,
    name: null,
    navigator: null,
    opener: null,
    outerHeight: null,
    outerWidth: null,
    pageXOffset: null,
    pageYOffset: null,
    parent: null,
    screen: null,
    screenLeft: null,
    screenTop: null,
    screenX: null,
    screenY: null,
    sessionStorage: null,
    scrollX: null,
    scrollY: null,
    self: null,
    status: null,
    top: null,
    addEventListener: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    alert: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    atob: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    blur: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    btoa: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    clearInterval: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    clearTimeout: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    close: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    confirm: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    focus: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    getComputedStyle: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    getSelection: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    matchMedia: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    moveBy: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    moveTo: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    open: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    print: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    prompt: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    resizeBy: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    resizeTo: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    removeEventListener: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    scroll: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    scrollBy: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    scrollTo: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    setInterval: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    setTimeout: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null),
    stop: (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => null)
};
/** @type {?} */
const WINDOW_MOCK = Object.assign({}, WINDOW_MOCK_WITHOUT_INTERSECTION_OBSERVER, { IntersectionObserver: (/**
     * @param {...?} args
     * @return {?}
     */
    function (...args) {
        this.observe = (/**
         * @return {?}
         */
        () => null);
        this.unobserve = (/**
         * @return {?}
         */
        () => null);
    }), IntersectionObserverEntry: class IntersectionObserverEntryMock {
    } });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * A simple lightweight library for Angular with other dependencies
 * that detects when an element is within the browsers viewport and adds a
 * sn-viewport--in or sn-viewport--out class to the element.
 */
class InViewportModule {
    /**
     * @return {?}
     */
    static forServer() {
        return {
            ngModule: InViewportModule,
            providers: [{ provide: WINDOW, useValue: WINDOW_MOCK }]
        };
    }
}
InViewportModule.decorators = [
    { type: NgModule, args: [{
                declarations: [InViewportDirective],
                exports: [InViewportDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { InViewportModule, InViewportDirective, WINDOW_MOCK, WINDOW };

//# sourceMappingURL=thisissoon-angular-inviewport.js.map