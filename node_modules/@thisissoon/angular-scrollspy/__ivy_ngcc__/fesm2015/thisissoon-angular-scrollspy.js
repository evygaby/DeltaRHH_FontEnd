import { Directive, Input, HostBinding, ChangeDetectorRef, Injectable, ContentChildren, Component, NgModule } from '@angular/core';
import { InViewportModule } from '@thisissoon/angular-inviewport';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * A directive used to add an `active` class to a nav item
 * when the section is in the viewport
 *
 * \@example
 * ```html
 * <a snScrollSpyItem for="foo" href="#section1">Section 1</a>
 * ```
 *
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@thisissoon/angular-inviewport';

const _c0 = ["*"];
class ScrollSpyItemDirective {
    /**
     * Creates an instance of ScrollSpyItemDirective.
     * \@memberof ScrollSpyItemDirective
     * @param {?} cdRef
     */
    constructor(cdRef) {
        this.cdRef = cdRef;
        /**
         * True if the nav item is the active item in the `items` list
         * for `ScrollSpyDirective` instance
         *
         * \@memberof ScrollSpyItemDirective
         */
        this.active = false;
        /**
         * If true means the section is in the viewport
         *
         * \@memberof ScrollSpyItemDirective
         */
        this.inViewport = false;
    }
    /**
     * Id of section that links navigates to
     *
     * \@readonly
     * \@memberof ScrollSpyItemDirective
     * @return {?}
     */
    get section() {
        return this.href.replace('#', '');
    }
    /**
     * Manually trigger change detection
     *
     * \@memberof ScrollSpyItemDirective
     * @return {?}
     */
    detectChanges() {
        this.cdRef.detectChanges();
    }
}
ScrollSpyItemDirective.ɵfac = function ScrollSpyItemDirective_Factory(t) { return new (t || ScrollSpyItemDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
ScrollSpyItemDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ScrollSpyItemDirective, selectors: [["", "snScrollSpyItem", ""]], hostVars: 2, hostBindings: function ScrollSpyItemDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("active", ctx.active);
    } }, inputs: { for: "for", href: "href" } });
/** @nocollapse */
ScrollSpyItemDirective.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
ScrollSpyItemDirective.propDecorators = {
    active: [{ type: HostBinding, args: ['class.active',] }],
    for: [{ type: Input }],
    href: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ScrollSpyItemDirective, [{
        type: Directive,
        args: [{
                selector: '[snScrollSpyItem]'
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { active: [{
            type: HostBinding,
            args: ['class.active']
        }], for: [{
            type: Input
        }], href: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Service that stores a list of `Spy`'s and the state
 * of their nav items `inViewport` and `active` state
 *
 */
class ScrollSpyService {
    constructor() {
        /**
         * List of `Spy`'s
         *
         * \@memberof ScrollSpyService
         */
        this.spys = [];
        /**
         * Stores requests to add items to spy when spy hasn't been created
         * yet. Once spy has been added then request will be made again.
         *
         * \@memberof ScrollSpyService
         */
        this.buffer = [];
    }
    /**
     * Add spy to list of `spys`
     *
     * \@memberof ScrollSpyService
     * @param {?} id
     * @param {?} items
     * @return {?}
     */
    addSpy(id, items) {
        this.spys.push({ id, items });
        /** @type {?} */
        const buffer = this.buffer.filter(i => i.spyId === id);
        this.buffer = this.buffer.filter(i => i.spyId !== id);
        buffer.forEach(i => this.setSpySectionStatus(i.sectionId, i.spyId, i.inViewport));
    }
    /**
     * Remove spy from list of `spys`
     *
     * \@memberof ScrollSpyService
     * @param {?} id
     * @return {?}
     */
    removeSpy(id) {
        /** @type {?} */
        const i = this.spys.findIndex(s => s.id === id);
        this.spys.splice(i, 1);
    }
    /**
     * Set the `inViewport` status for a spy item then sets the active
     * to true for the first item in the list that has `inViewport`
     * set to true
     *
     * \@memberof ScrollSpyService
     * @param {?} sectionId
     * @param {?} spyId
     * @param {?} inViewport
     * @return {?}
     */
    setSpySectionStatus(sectionId, spyId, inViewport) {
        /** @type {?} */
        const spy = this.spys.find(s => s.id === spyId);
        if (!spy) {
            this.buffer.push({ sectionId, spyId, inViewport });
            return;
        }
        /** @type {?} */
        const item = spy.items.find(i => i.section === sectionId);
        if (!item) {
            return;
        }
        item.inViewport = inViewport;
        /** @type {?} */
        const firstInViewport = spy.items.filter(i => i.inViewport)[0];
        spy.items.forEach(i => (i.active = false));
        if (firstInViewport) {
            firstInViewport.active = true;
            firstInViewport.detectChanges();
        }
    }
}
ScrollSpyService.ɵfac = function ScrollSpyService_Factory(t) { return new (t || ScrollSpyService)(); };
ScrollSpyService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ScrollSpyService, factory: ScrollSpyService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ScrollSpyService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Adds `active` class to navigation links when section is in the viewport.
 * Used in conjuction with `snScrollItem` directive which should be added
 * to anchor links in the nav
 *
 * \@example
 * ```
 * <ul role="navigation" snScrollSpy id="foo">
 *  <li><a snScrollSpyItem for="foo" href="#section1">Section 1</a></li>
 *  <li><a snScrollSpyItem for="foo" href="#section2">Section 2</a></li>
 *  <li><a snScrollSpyItem for="foo" href="#section3">Section 3</a></li>
 *  <li><a snScrollSpyItem for="foo" href="#section4">Section 4</a></li>
 * </ul>
 * ```
 *
 */
class ScrollSpyDirective {
    /**
     * Creates an instance of ScrollSpyDirective.
     * \@memberof ScrollSpyDirective
     * @param {?} scrollSpySvc
     */
    constructor(scrollSpySvc) {
        this.scrollSpySvc = scrollSpySvc;
    }
    /**
     * Adds spy to list of spys in `ScrollSpyService`
     *
     * \@memberof ScrollSpyDirective
     * @return {?}
     */
    ngAfterViewInit() {
        this.scrollSpySvc.addSpy(this.id, this.items);
    }
    /**
     * Remove spy from list of spys when directive is destroyed
     *
     * \@memberof ScrollSpyDirective
     * @return {?}
     */
    ngOnDestroy() {
        this.scrollSpySvc.removeSpy(this.id);
    }
}
ScrollSpyDirective.ɵfac = function ScrollSpyDirective_Factory(t) { return new (t || ScrollSpyDirective)(ɵngcc0.ɵɵdirectiveInject(ScrollSpyService)); };
ScrollSpyDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ScrollSpyDirective, selectors: [["", "snScrollSpy", ""]], contentQueries: function ScrollSpyDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ScrollSpyItemDirective, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.items = _t);
    } }, inputs: { id: "id" } });
/** @nocollapse */
ScrollSpyDirective.ctorParameters = () => [
    { type: ScrollSpyService }
];
ScrollSpyDirective.propDecorators = {
    items: [{ type: ContentChildren, args: [ScrollSpyItemDirective,] }],
    id: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ScrollSpyDirective, [{
        type: Directive,
        args: [{
                selector: '[snScrollSpy]'
            }]
    }], function () { return [{ type: ScrollSpyService }]; }, { items: [{
            type: ContentChildren,
            args: [ScrollSpyItemDirective]
        }], id: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * A component to wrap section content within that will update the
 * `ScrollSpyService` when it's in view
 *
 * \@example
 * ```html
 *  <sn-scroll-spy-section id="section1" for="foo">
 *    ...
 *  </sn-scroll-spy-section>
 * ```
 */
class ScrollSpySectionComponent {
    /**
     * Creates an instance of ScrollSpySectionComponent.
     * \@memberof ScrollSpySectionComponent
     * @param {?} scrollSpySvc
     */
    constructor(scrollSpySvc) {
        this.scrollSpySvc = scrollSpySvc;
    }
    /**
     * Updates `ScrollSpy` section when element enters/leaves viewport
     *
     * \@memberof ScrollSpySectionComponent
     * @param {?} inViewport
     * @return {?}
     */
    onInViewportChange(inViewport) {
        this.scrollSpySvc.setSpySectionStatus(this.id, this.for, inViewport);
    }
}
ScrollSpySectionComponent.ɵfac = function ScrollSpySectionComponent_Factory(t) { return new (t || ScrollSpySectionComponent)(ɵngcc0.ɵɵdirectiveInject(ScrollSpyService)); };
ScrollSpySectionComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ScrollSpySectionComponent, selectors: [["sn-scroll-spy-section"]], inputs: { id: "id", for: "for" }, ngContentSelectors: _c0, decls: 2, vars: 0, consts: [["snInViewport", "", 1, "sn-hidden", 3, "inViewportChange"]], template: function ScrollSpySectionComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("inViewportChange", function ScrollSpySectionComponent_Template_div_inViewportChange_0_listener($event) { return ctx.onInViewportChange($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(1);
    } }, dependencies: [ɵngcc1.InViewportDirective], styles: ["[_nghost-%COMP%]{display:block;position:relative}.sn-hidden[_ngcontent-%COMP%]{bottom:0;left:0;opacity:0;position:absolute;right:0;top:0;z-index:-1}"] });
/** @nocollapse */
ScrollSpySectionComponent.ctorParameters = () => [
    { type: ScrollSpyService }
];
ScrollSpySectionComponent.propDecorators = {
    id: [{ type: Input }],
    for: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ScrollSpySectionComponent, [{
        type: Component,
        args: [{ selector: 'sn-scroll-spy-section', template: "<div\n  class=\"sn-hidden\"\n  snInViewport\n  (inViewportChange)=\"onInViewportChange($event)\">\n</div>\n<ng-content></ng-content>\n", styles: [":host{display:block;position:relative}.sn-hidden{bottom:0;left:0;opacity:0;position:absolute;right:0;top:0;z-index:-1}"] }]
    }], function () { return [{ type: ScrollSpyService }]; }, { id: [{
            type: Input
        }], for: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const directives = [ScrollSpyDirective, ScrollSpyItemDirective];
/** @type {?} */
const components = [ScrollSpySectionComponent];
/** @type {?} */
const providers = [ScrollSpyService];
/**
 * A simple lightweight library for Angular which automatically
 * updates links to indicate the currently active section in the viewport
 *
 */
class ScrollSpyModule {
    /**
     * Specify a static method for root module to ensure providers are
     * only provided once but allows the module to still be imported
     * into other modules without reproviding services.
     *
     * \@memberof ScrollSpyModule
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: ScrollSpyModule,
            providers: [...providers],
        };
    }
}
ScrollSpyModule.ɵfac = function ScrollSpyModule_Factory(t) { return new (t || ScrollSpyModule)(); };
ScrollSpyModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: ScrollSpyModule });
ScrollSpyModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [InViewportModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ScrollSpyModule, [{
        type: NgModule,
        args: [{
                imports: [InViewportModule],
                declarations: [...directives, ...components],
                exports: [...directives, ...components]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ScrollSpyModule, { declarations: function () { return [ScrollSpyDirective, ScrollSpyItemDirective, ScrollSpySectionComponent]; }, imports: function () { return [InViewportModule]; }, exports: function () { return [ScrollSpyDirective, ScrollSpyItemDirective, ScrollSpySectionComponent]; } }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ScrollSpyDirective, ScrollSpyItemDirective, ScrollSpySectionComponent, ScrollSpyService, ScrollSpyModule };

//# sourceMappingURL=thisissoon-angular-scrollspy.js.map